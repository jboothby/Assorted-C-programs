#include "assignment7.h"
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>

#define SORT_THRESHOLD      40


typedef struct _sortParams {
    char** array;
    int left;
    int right;
} SortParams;

/* Function Prototypes */
static void *produce(SortParams *p);
static void *consumer();
    
static int maximumThreads;              /* maximum # of threads to be used */
static pthread_t *threads;              /* Array of thread ids */

/* Condition, threads wait for a job */
static pthread_cond_t jobReady = PTHREAD_COND_INITIALIZER;
static pthread_cond_t threadReady = PTHREAD_COND_INITIALIZER;
static int jobs;

/* Protects task variable */
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
static SortParams *task = NULL;

/* This is an implementation of insert sort, which although it is */
/* n-squared, is faster at sorting short lists than quick sort,   */
/* due to its lack of recursive procedure call overhead.          */

static void insertSort(char** array, int left, int right) {
    int i, j;
    for (i = left + 1; i <= right; i++) {
        char* pivot = array[i];
        j = i - 1;
        while (j >= left && (strcmp(array[j],pivot) > 0)) {
            array[j + 1] = array[j];
            j--;
        }
        array[j + 1] = pivot;
    }
}

/* Recursive quick sort, but with a provision to use */
/* insert sort when the range gets small.            */

static void quickSort(void* p) {
    
    SortParams* params = (SortParams*) p;
    char** array = params->array;
    int left = params->left;
    int right = params->right;
    int i = left, j = right;

    if (j - i > SORT_THRESHOLD) {           /* if the sort range is substantial, use quick sort */

        int m = (i + j) >> 1;               /* pick pivot as median of         */
        char* temp, *pivot;                 /* first, last and middle elements */
        if (strcmp(array[i],array[m]) > 0) {
            temp = array[i]; array[i] = array[m]; array[m] = temp;
        }
        if (strcmp(array[m],array[j]) > 0) {
            temp = array[m]; array[m] = array[j]; array[j] = temp;
            if (strcmp(array[i],array[m]) > 0) {
                temp = array[i]; array[i] = array[m]; array[m] = temp;
            }
        }
        pivot = array[m];

        for (;;) {
            while (strcmp(array[i],pivot) < 0) i++; /* move i down to first element greater than or equal to pivot */
            while (strcmp(array[j],pivot) > 0) j--; /* move j up to first element less than or equal to pivot      */
            if (i < j) {
                char* temp = array[i];      /* if i and j have not passed each other */
                array[i++] = array[j];      /* swap their respective elements and    */
                array[j--] = temp;          /* advance both i and j                  */
            } else if (i == j) {
                i++; j--;
            } else break;                   /* if i > j, this partitioning is done  */
        }
        
        SortParams *first = malloc(sizeof(SortParams));
        first->array = array; first->left = left; first->right = j;
       // quickSort(&first);
        produce(first);                  /* sort the left partition  */

        SortParams *second = malloc(sizeof(SortParams));
        second->array = array; second->left = i; second->right = right;
       // quickSort(&second);
        produce(second);                 /* sort the right partition */

        //TODO flag
                
    } else{
         insertSort(array,i,j);
         //printf("Thread %ld exiting\n", pthread_self());
        // pthread_exit(0);
    }
}

/* Produce a job using input */
static void *produce(SortParams *p){
    printf("Reached produce, thread(%ld)\n", pthread_self());
    pthread_mutex_lock(&mutex);             // Lock mutex to access task var
    if( task != NULL ){                     // Wait for task to be empty
        printf("Wait thread ready, thread (%ld)\n", pthread_self());
        pthread_mutex_unlock(&mutex);
        quickSort(p);
        pthread_mutex_lock(&mutex);
        pthread_cond_wait(&threadReady, &mutex);
    }
    assert(task == NULL);                   // Ensure task actually empty
    task = p;                               // post the task
    printf("Signal job ready, thread (%ld)\n", pthread_self());
    pthread_cond_signal(&jobReady);         // Signal threads to wake up
    pthread_mutex_unlock(&mutex);           // Unlock Mutex
}
        

/* Keep threads in pool waiting to be signalled to do a subarray sort */
static void *consumer(){
    //printf("Reached consumer, thread(%ld)\n", pthread_self());
    while(1){
        SortParams temp;
        temp.array = NULL;
        pthread_mutex_lock(&mutex);                 // Lock mutex to access task var
        if( task == NULL ){                         // Wait for task
            printf("Wait job ready, thread (%ld)\n", pthread_self());
            pthread_cond_wait(&jobReady, &mutex);   
        }
        if (task != NULL){                          // If job available
            temp.array = task->array;
            temp.left = task->left;
            temp.right = task->right;
            free(task);
            task = NULL;                            // Empty job variable
            printf("Signal thread ready, L:%d R:%d, thread (%ld)\n",temp.left, temp.right, pthread_self());
            pthread_cond_signal(&threadReady);      // Signal that job var is empty
        }
        pthread_mutex_unlock(&mutex);               // Unlock mutex
        if (temp.array) quickSort(&temp);                  // Sort new task
    }
}

/* user interface routine to set the number of threads sortT is permitted to use */

void setSortThreads(int count) {
    maximumThreads = count;
    threads = (pthread_t*)calloc(maximumThreads, sizeof(threads));   /* Allocate space for thread id array */
    jobs = 0;                                                        /* Initialize jobs to 0 (nothing to do yet) */
}

/* user callable sort procedure, sorts array of count strings, beginning at address array */

void sortThreaded(char** array, unsigned int count) {
    int s, i;

    SortParams parameters;
    parameters.array = array; parameters.left = 0; parameters.right = count - 1;


    // Create each thread in pool and send to consumer
    for( i = 0; i < maximumThreads; i++){
       s = pthread_create(&threads[i], NULL, consumer, NULL);
       printf("Creating thread id (%ld)\n", threads[i]);
       if( s > 0){
           printf("Error <%d> on pthread_create\n", s);
           exit(-1);
       }
    }
    quickSort(&parameters);
   // produce(&parameters);

    // Wait for thread to join before returning
    for( i = 0; i < maximumThreads; i++){
        s = pthread_join(threads[i], NULL);
        printf("Joining thread %d\n", i);
        if( s > 0 ){
            printf("Error <%d> on pthread_join\n", s);
            exit(-1);
        }
    }

    if( threads != NULL ){
        free( threads );
    }
    
    return;
}

